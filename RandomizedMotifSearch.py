

import random

import numpy as np

from collections import Counter, defaultdict

import heapq

import operator

from functools import reduce



 

def random_kmer_selection(k, t, Dna):

    l = len(Dna[0])

    kmers = []

    for dna in Dna:

        n = random.randrange(l - k)

        kmers.append(dna[n:n + k])

    return kmers

 

def Profile(List, k, t):

    List = np.asarray([list(item) for item in List])

    pro = np.ones(shape=(4, k))

    for i in range(k):

        c = Counter(List[:, i])

        pro[0, i] = pro[0, i] + c['A']

        pro[1, i] = pro[1, i] + c['C']

        pro[2, i] = pro[2, i] + c['G']

        pro[3, i] = pro[3, i] + c['T']

    return pro / float(t + 1)

 

def Score(List, k, t):

    List = np.asarray([list(item) for item in List])

    score = 0

    for i in range(k):

        c = Counter(List[:, i])

        score += t - c.most_common(1)[0][1]

    return score

 

def compute(kmer, order, profile):

    c = []

    for i in range(len(kmer)):

        c.append(profile.item(order.index(kmer[i]), i))

    return reduce(operator.mul, c, 1)

 

def correct(seq, k):

    return set([seq[i:i + k] for i in range(len(seq) - k + 1)])

 

def pmpkp(dna, k, order, profile):

    corrects = correct(dna, k)

    return heapq.nlargest(1, [(kmer, compute(kmer, order, profile)) for kmer in corrects], key=lambda x: x[1])[0][0]

 

def Motifs(profile, k, t, Dna):

    order = ['A', 'C', 'G', 'T']

    return [pmpkp(dna, k, order, profile) for dna in Dna]

 

def random_motif_search(k, t, Dna):

    bestmotifs = random_kmer_selection(k, t, Dna)

    initial_motifs = random_kmer_selection(k, t, Dna)

    while True:

        profile = Profile(initial_motifs, k, t)

        motifs = Motifs(profile, k, t, Dna)

        if Score(motifs, k, t) < Score(bestmotifs, k, t):

            bestmotifs = motifs

            initial_motifs = motifs

        else:

            yield bestmotifs

            break

 

def result(k, t, Dna):

    bm = []

    lowest_bestscore = float('inf')

    lowest_motifs = []

    i = 0

    while True:

        bestmotifs = list(random_motif_search(k, t, Dna))[0]

        bestscore = Score(bestmotifs, k, t)

        if bestscore < lowest_bestscore:

            lowest_bestscore = bestscore

            lowest_motifs = bestmotifs

            i = 0

        else:

            i += 1

        if i > 1200:

            break

    return lowest_motifs

 

k, t = 15, 20

Dna = [

     "GGGATACATGGCAGGCTAATCGTGTAAGAAGAGTCGCCATTACCGCCTCCTCTGCTCCGTTTGTGACATGGGCCCCTCTCGGGGTGACGCTGCGCATATATGTCAGTGTGTATATGCCGTAACCACCGTGGTGGTTTATTGATGTTACCCCTTCAGGATTCGTAACGGACCAGGGCCGTTTGATATCTAGACACGGGGATACATGGCAGG", "CTAATCGTGTAAGAAGAGTCGCCATTACCGCCTCCTCTGCTCCGTTTGTGACATGGGCCCCTCTCGGGGTGACGCTGCGCATATATGTCAGTGTGTATATGCCGTAACCACCGTGGTGGTTTATTGATGTTACCCCTTCAGGATTCGTAACGGACCAGGGCCGTTTGATATCGTTCAGTGAAGAGTTTAGACACGGGGATACATGGCAGG", "AAATGTACTAGAGCGTTTCTTGAAGTACTCTCTCGACTCTCAGTCGATCAAGGGGGCGTAGTTGGCCGTAGGTCGTAAGGACAGCTACGGAGATTCAAATGCCTTTCACCACATCGCTAATAAGACCCGATAACCTTTGAGGTGCGGAATCATTCGTCGAGTCGGATACGCTCAAGGAGATTCCACCACGGCGTAATGGTAATAGCTACG", "ACCTTACCTGATTAAGTTGTGACAAAGTGGAGCGTACTACGCCACAACCACTTACCGTAGAAATCGCTCTTACATCCTTAGTAATGGTGCTATGATGTCGGTCCACTGCGCTGGTACATCTTTGTTTCTTGAAGAAGCAAAGCTACCTCAATCATGCTTGTCATTTGAAAGGGAAGACGCTGTGGGCTGTCGCCTATTCCTTCAGGTTCA", "TCAGTTGAATACGGGGGCGGCATGGGAGCAATGGGGGGCGCGGCCGCTCCACGTCGGGTAGAACATCCGAGGCAAACGGGCCAAGGCAAGGATCAGAACGGCCTGCCTGTGGGATCTCGGGGTACAGTACCTGCGTTGCGTCTCGTTCGCTGAAGAGTTACACGGGTAGCGATGAGCTAAGTATCAATATATATGTAACTGGCTGGTGAC", "GAGAAAATTCATCCATTGGTATTCTGTGCTTGAAACTGCTACATCGCAAAACACTTGTTACTATGTAGTGGAGGAGCTAGTTGTATGAGGAACCTCCGCGCTACCCCGGGACAATGCAAGACCACGACTGAGTTGCTCTTGAAGAGTTTAGTTTGTTAGTTCCCGCTTGTCCTTCCGCAAGCACATCCGAGCTTTCACTCGGAGCGAGAT", "ACTCTATGCTGATCTTATCACCGCTAGTGAAGAGTCTCTTATTTAACTTCCATACTCTGTCAGGTGTATATGTTTACCGCCCGACCGTAAGCGCGTGAGAGCAGAACGCCGCACTAACGATGTCATTAACACTCCGAGTAAACGTGATGTTCCGCGCCTGGGAACGTTTCTCTTAGAGTTCCGTGTAAAACGCTGTGGTCTTCCCCTCTG", "TACAGTATTTCACGGGCACCCAAGACTGTGCAACCGTACTCACCGTAAGTGTGTCTATTAATCTCCATCAGCAGGGGCGACGCACGTCAAAGAGGACTTATACAGTTCGCCGCACCTGTGATCTCAGTCGATTGCGTTGAAATGTCATGCCCGAAACACCTCGGTCCTGCCGACAAGTCTGGCGCGTACGTTGAAGAGTTATACTAGGAA", "CGTGGCCCCCCTCTAGCCCTCTCCAGTGCCCTGGAGACATGTTCAACAGGTTTAACGAAGAGTTCAGGCAGTATACGGAGTTAACAACGTGGACATGGATTGCATATGAAGTGACACGACCACTTCAAAGGGCCCTGCCGACCTGGGCTCCAGACCAGGCTGACTAATAGGCGACCCCCGGAAGGTTCATTCAGGTGGGTAAAACATATG", "CGCTCACATGTGTGAACACATTTTCCTCCTTAAACATAGGCGAGGGCTTGCATTTCTTCTTGAAGAGTGTTTCAATTGGTACAAGACCAAGTGGCACGCACAGCTTCCATGACCACTTAGGTTGCGGCACCCTCTATTGACGTACGGGCATTAGAGTTGTGTGCTAAAGAGCTATCTTCCTTAGGCTTATACGGTATTTAGGAGACTTGT", "TATGGTTGGGATTCTCCACTGTCCGAGGGGGGCCGAAATATCTGGGTAGCGCGTGGAGGACCGCGTCAGCAACGCCTCTATTAGAGCAAGTTAAGTTCGTAAGTGGATGGAACGGCGTGGGGTTGTTCTAAGTTTCTTGATATGTTAACTAGCGATGCACATGCTTGCAGGGCATTTTGCGGATTGCCGTCGATTTAAAGATCGGTGGCG", "ACAGCGAACTCCGTCGTCCTATACCGATGAATAACCAATTGAACACGCGCGGTAAAAAGGAGAATAGTTTCTTGTGAAGTTGACTTGGTTGTTTGGATAAGACCAGGTCCCGACCGCGGGCAACACTGTTAGCAGGGATCACTCAGGATCTCGCCGGCGATGATGAGACTCGGAGCCTCCAGATTGCCCTGTTTCGGCGGGAGCCAACTC", "AAATTTGCCGTTTTCCCCAGCTATGAATGCAGCACGCGACGATTTTTTGCAAAAGTCTCAGATTATAGCCACGCCTTGCTAGAGAACGCCCCTTAACGTGTGGCAGGTCCGGAAGACCCGCAGTAGCTGGGTTCGTTTCCAAAAGAGTTACATCCATCATCGTCCACCGGCTCGAACACCAATATGCGTAAATCGAGGGTGTTTGGGCAG", "AACGCACTTGGCCTCCGCCACCTACTCAGAATGCAGATAGTCGGCGTTGGAGGGAGAGGCCAATAACCCTGTCTAGCGGATGCTTAGTGCGTCTGTGCAAGCATTACGGCAAAAGCGGCTGAGCAGATCGCAATCCCGCCGGACTAAGGACAAGGGTATGTGGATTTTGCGGGAGGCGGCTTGAAGAGTTTCCCTTTGGGCTCACGAATA", "GCAGATGAGTACCGCAATGTCGTCTAGAGTCATGCGTTCTAAACAAGTAGCGGATCGACATTACGGCCATGCTGAGTATCTCCCCACGTTTCTTGAACCCTTGTGGCAGGGGTACCCCGGACCGTCCAAGAGAGGGATTAACTGGACTCCGGGGCAATCGGTGCCCTCATGGGACCATCCGGACAAGTTATGCGGATGTCCCCAACACGG", "TCTCTTCTGCGATACTTTGAATCGTCATCCCGCAAACTACACAAGGGCACAACTGCACCCTAGTCAGTAACGAGATGTTTTTTGTAACACCAACGCCACCCCACGCCCAGGACTATGTGTCCAATAAGACTTGCGCTTAGGTATACGTCTGGTACTTACACGTGTACATCCGATGTATGGAACGTTTCTTAGCGAGTTTACGAGCGGCGA", "ACATCCCACCCTTATATGATTTTCTTATCGAACCCGGGCTCCGCGCGGCACGCTACCATGCGGTCACGTGGAATGCGTTCGTCCACCTTTGCTTCCGGGGCAGCATTTCTTGAAGAGAACTCGAACATCACGGCTATCAATTATAACCCCTCACTACATGTCCCGCCGCCGTACAGCCTGACCCCATTTGGTAAAAGGTTTCGGGACTAT", "CAACCAGAGGTTTTGGTAGCGTGAGGATTCCTATTCCTGGAGTTCTGGTTCTCGATTTCATAATAAAACAGCAGGCTCATACACATCGTCGGGCGGCAGCATCTCCCGTGGAACGACTCATTCTCGGTTCTAATATCATCATCGTTTCTGAGAGAGTTTATCTACTAGTTCTTCACTGATGGACACGGGCGTTAGGGATGCATTCCGCGC", "AAGAGAAGCGTGCGATAGTTGAAGAAAATACAAGGGGTCGAGCCCTCGTGGAGACCGAATGGTGGCTCACTCTAGCGACATGTTTGCTTTATTCTCTCAACAAAGTCTACAGACCGGCCCGCTACAGAGCCTTATCAGCTTCAGTTTCCCTAAGAGTTTAATTCTCGTACCCAGTCCGATAGTCGTGTAACCTTATGTTGTCATCCCTGC", "GACGGCAGGAAAAATAGCTCCAGGAATTGTACGGAAACCCGGGGCGCTCAGTGCTCCAGCGTGGTGTGTTCCGTCTCTGCTTCTGACGCCGGTTCCTTTCGCGCTCTTTTACACCTTCCGTTTAGGGAAGAGTTAAATTACTTCGCTATCCAATCCTCTAAGTGACTCCCCCCGGTGGCACTCCCATAGCGGATCCAAACCGCCACATCT"
      
      ]

 

results = result(k, t, Dna)

print('\n'.join(results))